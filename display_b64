#!yasl

// スタック0トップのエラーメッセージを出力して終了
{ 0:print "\n":0 0:print 1:0 0:exit } error_exit

// スタック8内部のデータに改行を加えて出力
// (スタック8が空の場合は改行だけ出力)
{ 8:#:8 8:=:8 0:8 8:!= ? ( 8:#(8:print) ) "\n":8 8:print } print_stack

// スタック0トップの数nが平方数なら, その平方根をスタック0トップに置く
// そうでないなら0をスタック0トップに置く
// (入力nは失われる)
{
	0:=:1
	0:!
	1:0 // k
	1:0 0:@(
		// スタック0のトップは k
		// スタック1のトップは与えられた数 n

		// k * k == n なら, nは平方数であり, kはnの平方根 -> 0のトップにkを置いて終了
		1:=:1
		0:=:1 0:=:1 1:*:1
		1:== ?(
			// "is square!!\n":1 1:print
			0:0
		) : (
			// k * k > n なら, nは平方数ではない -> 0のトップに0を置いて終了
			1:=:1
			0:=:1 0:=:1 1:*:1
			1:< ?(
				// "is not square!!\n":1 1:print
				0:!
				0:0
				0:0
			) : (
				// -> kを1増やしてループを継続
				1:0
				0:+:0
				1:0
			)
		)
	)	
	1:!
} is_sqrt

// データをBase64文字列として考えた時、「正方形の画像」を表せるか？ 
// -> 「文字数が4の倍数」かつ「ピクセル数S(=文字数 / 4)が平方数かどうか」
// validなら, スタック0トップにサイズLを置く
{
	// スタック9は[文字数, データ]
	(
		// 「文字数が4の倍数」
		9:=:9
		4:9
		9:%:9
		0:9
		9:!= ? ( "error: image is not a valid base64":0 error_exit )
	)
	(
		// 「ピクセル数S(= 文字数 / 4)が平方数かどうか」
		9:=:9
		4:9
		9:/:9
		// 9のトップは 文字数 / 4
		9:=:0
		0:=:0
		is_sqrt

		0:=:0
		0:0
		0:== ? ( "error: image is not a square":0 error_exit )
		9:!
		9:!
	)
} sqrt

// 与えられた文字cが start <= c <= end を満たすなら,
// c - start を返す. そうでないなら 0 を返す.
//
// 引数はスタック0に [end, start, c] の順に与えられる.
// 結果はスタック0に [boolean(, result)] の順に置かれる.
// ただし boolean は, start <= c <= end かどうかを表し,
// これが成り立つ場合のみ, c - start が result として与えられる.
{
	0:=:3 // end on 3
	0:!
	0:=:2 // start on 2
	0:!
	0:=:1 // c on 1
	0:!
	2:=:0 1:=:0 0:<=:0 // start <= c
	1:=:0 3:=:0 0:<=:0 // c <= end
	
	0:&&:0 0:? (
		// start <= c <= end
		1:=:1 2:=:1 1:-:0
		1:0
	): (
		0:0
	)
	1:! 2:! 3:!
} atoi_range

// base64
// "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

// 与えられた文字cを, base64に従い 0 - 63 の整数に変換する.
// 文字cはスタック0トップとして与える.
{
	0:=:1 // c をスタック1に退避
	0:!
	// "A" <= "c" <= "Z"
	1:=:0 "A":0 "Z":0 atoi_range 0:? (
		// -> スタック0トップをそのまま返す
	) : (
		// "a" <= "c" <= "z"
		1:=:0 "a":0 "z":0 atoi_range 0:? (
			// -> スタック0トップに26を足して返す
			26:0 0:+:0
		) : (
			// "0" <= "c" <= "9"
			1:=:0 "0":0 "9":0 atoi_range 0:? (
				// -> スタック0トップに52を足して返す
				52:0 0:+:0
			) : (
				// c == "+"
				1:=:0 "+":0 0:== 0:? (
					// -> 62を返す
					62:0
				) : (
					// c == "/"
					1:=:0 "/":0 0:== 0:? (
						// -> 63を返す
						63:0
					) : (
						// -> エラー
						1:0 0:exit
					)
				)
			)
		)
	)
	// 退避した c を破棄
	1:!
} decode_base64

// -------------------------------------------------------

#!

// 標準入力からデータDを受け取る。
read:9

// データの正当性をチェックする: 
sqrt

// データサイズが valid なら, スタック0は [S, L] になっている

// スタック9の中身をbase64デコードしてスタック3に詰める.
// おかしな文字があればexit
9:][:9
9:#(
	9:=:0
	9:!
	decode_base64
	0:=:3
	0:!
)

// ピクセル数Sと画像サイズLを出力する。
// スタック0トップはサイズL, スタック1トップはピクセル数S
2:0
0:^
0:=:1
0:!
1:=:8 "image received, nb pixels : ":8 print_stack
0:=:8 "found square : ":8 print_stack

// [ここまでの状況]
// スタック0: [L]
// スタック1: [S]
// スタック2: []
// スタック3: [デコードされたイメージデータ[S]]
"stack 0 #: ":0 0:print 0:#:0 0:print "\n":0 0:print
"stack 1 #: ":0 0:print 1:#:0 0:print "\n":0 0:print
"stack 2 #: ":0 0:print 2:#:0 0:print "\n":0 0:print
"stack 3 #: ":0 0:print 3:#:0 0:print "\n":0 0:print

// 画像を表示する: 
// L回ループする: 
0:=:2 2:=:2 2:@ (
	1:2 2:-:2 2:=:2 // スタック2トップをデクリメント
	// L回ループする: 
	0:=:2 2:=:2 2:@ (
		1:2 2:-:2 2:=:2 // スタック2トップをデクリメント

		// ピクセルデータpを0で初期化する。
		0:8

		// 4回ループする: 
		4:2 2:=:2 2:@ (
			1:2 2:-:2 2:=:2 // スタック2トップをデクリメント

			// Dの先頭1文字を取り、0~63の整数に変換する(bx)。
			// pの下位6ビットにbxを挿入する。
			// pを8ビットずつ3つに分割し, 「1ピクセル分の文字表現(エスケープシーケンス)」として出力する。
		) 2:!
		// "\e[48;2;250;100;150m\e[0m":0 0:print

	) 2:!
	// 改行を出力する。
	"\n":0 0:print
) 2:!

// 0:print "\n":0 0:print


